from typing import List, Optional
from sqlalchemy import and_, or_, select, update, delete as delete_query
from sqlalchemy.orm import selectinload
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from src.models import User, Task, Habit, Tag
from src.models.task import TaskPriority, TaskStatus
from src.schemas.common_enums import SortOrder, TaskSortBy
from src.schemas.task_dto import TaskCreate, TaskUpdate
from src.utils.date_handling import make_aware, normalize_dates 


class TaskRepository:
    """
    Class repository for all operations with the _TASK_ model in the database.
    Encapsulates all logic for database queries.
    """

    async def create(self, db: AsyncSession, user_id: int, task_in: TaskCreate) -> Task | None:
        """Creates a new task for the specified user."""

        task_data  = task_in.model_dump()
        if "deadline" in task_data and task_data["deadline"] is not None:
            task_data ["deadline"] = make_aware(task_data ["deadline"])

        db_task = Task(**task_data , user_id=user_id)

        try:
            db.add(db_task)
            await db.commit()
            # Update the object to get the ID and other fields generated by the database
            await db.refresh(db_task)
            created_task_with_relations = await self.get_by_id(db=db, user_id=user_id, task_id=db_task.id)
            return created_task_with_relations
        except IntegrityError:
            # If an integrity error occurs (e.g., a duplicate),
            await db.rollback()
            return None


    async def get_by_id(self, db: AsyncSession, user_id: int, task_id: int) -> Task | None:
        query = (
            select(Task)
            .filter(and_(Task.id == task_id, Task.user_id == user_id))
            .options(selectinload(Task.tags))
        )

        result = await db.execute(query)
        return result.scalar_one_or_none()


    async def get_multi_for_user(
        self,
        db: AsyncSession,
        user_id: int,
        status: Optional[TaskStatus] = None,
        priority: Optional[TaskPriority] = None,
        tag_ids: Optional[List[int]] = None,
        sort_by: Optional[TaskSortBy] = None,
        sort_order: SortOrder = SortOrder.DESC,
        limit: Optional[int] = None,
    ) -> List[Task]:
        """
        Receives a list of tasks for the user with the ability to
        sort, filter, and limit.
        """

        query = (
            select(Task)
            .filter(Task.user_id == user_id)
            .options(selectinload(Task.tags))
        )

        # 2. APPLYING FILTERS (WHERE clause)
        if status is not None:
            query = query.filter(Task.status == status)
        if priority is not None:
            query = query.filter(Task.priority == priority)
        if tag_ids:
            query = query.filter(Task.tags.any(Tag.id.in_(tag_ids)))

        # 3. APPLYING SORTING (ORDER BY clause)
        if sort_by:
            sort_column = getattr(Task, sort_by.value, None)
            # Checking that the sorting field actually exists in the Task model
            if sort_column is not None:
                if sort_order == SortOrder.DESC:
                    query = query.order_by(sort_column.desc())
                else:
                    query = query.order_by(sort_column.asc())
        else:
            # Default sorting if nothing is specified
            query = query.order_by(Task.created_at.desc())

        # 4. APPLYING A LIMIT (LIMIT block)
        if limit is not None:
            query = query.limit(limit)

        result = await db.execute(query)
        return result.scalars().all()


    async def update(
            self, 
            db: AsyncSession,
            user_id: int, 
            task_id: int, 
            data_to_update: TaskUpdate
    ) -> Task | None:
        """
        Updates the task belonging to the specified user.
        Returns a 404 error if the task is not found or does not belong to the user.
        """
        updated_data = data_to_update.model_dump(exclude_unset=True)
        if not updated_data:
            return await self.get_by_id(db=db, user_id=user_id, task_id=task_id)
        
        updated_data = normalize_dates(updated_data, ["deadline", "completed_at"])

        query = (
            update(Task)
            .filter(and_(Task.id == task_id, Task.user_id == user_id))
            .values(**updated_data)
        )
        result = await db.execute(query)

        if result.rowcount == 0:
            return None

        await db.commit()

        # Return the updated task with tags
        return await self.get_by_id(db=db, user_id=user_id, task_id=task_id)


    async def delete(self, db: AsyncSession, user_id: int, task_id: int) -> bool:
        """
        Deletes a task belonging to the user.
        Returns True if successful, and False if the task is not found.
        """
        query = (
            delete_query(Task)
            .filter(and_(Task.id == task_id, Task.user_id == user_id))
        )

        result = await db.execute(query)
        await db.commit()

        # result.rowcount contains the number of rows deleted.
        # If it is > 0, it means we deleted one record.
        return result.rowcount > 0



task_repo = TaskRepository()