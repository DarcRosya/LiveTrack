from typing import Any, List, Optional
from fastapi import HTTPException, status
from pydantic import EmailStr
from sqlalchemy import and_, or_, select, update, delete as delete_query
from sqlalchemy.orm import selectinload
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from src.models import User, Task, Habit, Tag
from src.models.task import TaskPriority, TaskStatus
from src.schemas.common_enums import SortOrder, TaskSortBy
from src.schemas.task_dto import TaskCreate, TaskUpdate
from src.utils.date_validation import make_aware 


class TaskRepository:
    """
    Class repository for all operations with the _TASK_ model in the database.
    Encapsulates all logic for database queries.
    """

    async def create(self, db: AsyncSession, user: User, task_in: TaskCreate) -> Task:
        """Creates a new task for the specified user."""

        task_data  = task_in.model_dump()
        if "deadline" in task_data and task_data["deadline"] is not None:
            task_data ["deadline"] = make_aware(task_data ["deadline"])

        db_task = Task(**task_data , user_id=user.id)

        try:
            db.add(db_task)
            await db.commit()
            # Update the object to get the ID and other fields generated by the database
            await db.refresh(db_task)
            return db_task
        except IntegrityError as e:
            # If an integrity error occurs (e.g., a duplicate),
            # rollback the transaction and throw a clear error.
            await db.rollback()
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=f"Database integrity error: {e.orig}"
            )


    async def get_by_id(db: AsyncSession, user_id: int, task_id: int) -> Task | None:
        query = (
            select(Task)
            .filter(and_(Task.id == task_id, Task.user_id == user_id))
        )

        result = await db.execute(query)
        return result.scalar_one_or_none()


    async def get_multi_for_user(
        self,
        db: AsyncSession,
        user_id: int,
        status: Optional[TaskStatus] = None,
        priority: Optional[TaskPriority] = None,
        tag_ids: Optional[List[int]] = None,
        sort_by: Optional[TaskSortBy] = None,
        sort_order: SortOrder = SortOrder.DESC,
        limit: Optional[int] = None,
    ) -> List[Task]:
        """
        Receives a list of tasks for the user with the ability to
        sort, filter, and limit.
        """

        query = (
            select(Task)
            .filter(Task.user_id == user_id)
            .options(selectinload(Task.tags))
        )

        # 2. APPLYING FILTERS (WHERE clause)
        if status is not None:
            query = query.filter(Task.status == status)
        if priority is not None:
            query = query.filter(Task.priority == priority)
        if tag_ids:
            query = query.filter(Task.tags.any(Tag.id.in_(tag_ids)))

        # 3. APPLYING SORTING (ORDER BY clause)
        if sort_by:
            sort_column = getattr(Task, sort_by.value, None)
            # Checking that the sorting field actually exists in the Task model
            if sort_column is not None:
                if sort_order == SortOrder.DESC:
                    query = query.order_by(sort_column.desc())
                else:
                    query = query.order_by(sort_column.asc())
        else:
            # Default sorting if nothing is specified
            query = query.order_by(Task.created_at.desc())

        # 4. APPLYING A LIMIT (LIMIT block)
        if limit is not None:
            query = query.limit(limit)

        result = await db.execute(query)
        return result.scalars().all()


    async def update(
            self, 
            db: AsyncSession,
            user_id: int, 
            task_id: int, 
            data_to_update: TaskUpdate
    ) -> Task | None:
        """
        Updates the task belonging to the specified user.
        Returns a 404 error if the task is not found or does not belong to the user.
        """
        updated_data = data_to_update.model_dump(exclude_unset=True)

        get_query = (
            select(Task)
            .filter(and_(Task.id == task_id, Task.user_id == user_id))
            .options(selectinload(Task.tags))
        )

        if not updated_data:
        # If there is nothing to update, you need to get and return the current state of the task.
        # This is more correct behavior for PATCH.
            result = await db.execute(get_query)
            task = result.scalar_one_or_none()
            if not task:
                raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Task not found")
            return task
        

        for field in ("deadline", "completed_at"):
            if field in updated_data and updated_data[field]:
                updated_data[field] = make_aware(updated_data[field])

        query = (
            update(Task)
            .filter(and_(Task.id == task_id, Task.user_id == user_id))
            .values(**updated_data)
        )
        result = await db.execute(query)

        if result.rowcount == 0:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Task not found")

        await db.commit()

        # Return the updated task with tags
        result = await db.execute(get_query)
        return result.scalar_one_or_none()


    async def delete(self, db: AsyncSession, user_id: int, task_id: int) -> bool:
        """
        Deletes a task belonging to the user.
        Returns True if successful, and False if the task is not found.
        """
        query = (
            delete_query(Task)
            .filter(and_(Task.id == task_id, Task.user_id == user_id))
        )

        result = await db.execute(query)
        await db.commit()

        # result.rowcount contains the number of rows deleted.
        # If it is > 0, it means we deleted one record.
        return result.rowcount > 0



task_repo = TaskRepository()